# <자바스크립트의 시작>

## 1. Javascript 객체 기본

  - 객체 : 서로 연관된 변수와 함수를 그룹핑하고 이름을 붙인 것
  - 목록만 있으면 되는 경우에는 배열을 쓰면 되지만 각각의 데이터가 어떤 데이터인지를 풍부하게 설명해야하는 경우는 객체를 사용
  - 객체에서의 반복문 : 배열에서 사용하는 for문과는 문법이 조금 다른 for-in 문 사용
  - 객체에서는 key 값을 이용해 value 값을 불러옴
  - this: 어떤 메소드에서 그 메소드가 속해 있는 객체를 가리키는 특수한 키워드
  - new를 붙이면 객체를 생성하는 생성자(constructor)가 됨
  - prototype : 원형
  - 자바스크립트는 prototype based language
  - 여러개의 객체가 하나의 함수를 공유함으로써 prototype을 이용해 객체의 재사용성을 높임
  - 생성자 함수 안에 메소드를 정의하는 코드가 들어 있지 않기 대문에 객체가 생성될 때마다 호출되지 않고 한번만 생성 = 메모리 절약
  - sum의 내용이 수정된다 해도 한번만 수정하면 됨
  - 하나의 객체에서만 함수를 다르게 동작시키고 싶다면 그 객체에 메소드를 추가함.
  - 객체의 속성들 (변수들)은 생성자 함수 안에 넣는 것이 일반적
  - 객체의 메소드들은 생성자의 prototype에 추가하는 것이 일반적인 패턴
  - 다른 많은 언어들은 객체를 만드는 공장으로써 class를 지원, contructor의 대체재라고 할 수있는 class
  - class는 ECMA script 6부터 도입된 문법
  - https://babeljs.io/ 은 새로운 문법을 기존의 문법으로 치환해주는 javascript compiler
  - constructor 함수 : 객체의 초기 값을 지정하기 위해서 객체가 생성될 때 실행되기로 약속된 함수
  - 자바스크립트는 객체를 생성할때 자동으로 constructor 함수를 호출

## 2. Javascript 객체 고급

  - class에 어떤 기능을 추가하고 싶은데 만약 남이 짠 코드라 수정할 수 없는 경우나 추가하고 싶은 기능이 거의 사용되지 않는 경우 전체 코드를 수정하는 것은 부담스러운 일
  - extends 이용하여 상속
  - 상속을 도입했을때 문제 중 하나. 자식, 부모 클래스 관계에서의 문제.
  - 부모클래스에게 일을 시키고 부모가 하지 못하는 일은 난만 하도록 = super
  - 객체 지향 프로그래밍은 크게 두가지 요소 : 객체를 만들어 내는 공장, 설계도인 class, class를 통해 만들어진 객체
  - 주류 객체 지향 언어에서의 상속 : sub class가 super class의 기능을 물려받기 위해서 sub가 super의 자식이 되고 sub를 통해 객체를 생성해냄
  - 따라서 이 객체가 어떠한 기능을 갖게 될 것인지는 class 단에서 결정, 객체가 다른 객체의 상속의 받는 등의 경우는 불가능
  - 자바스크립트에도 class라는 키워드는 있지만 이것은 장식에 불과하고 내부 동작 방식이 바뀐 것은 아님. 자바스크립트는 이것보다 더 자유롭고 복잡하게 상속을 구현
  - 어떤 super object가 있고 이 객체의 기능을 상속 받으면서 새로운 기능을 추가하고 싶은 sub object있으면 sub object는 super object로부터 바로 상속을 받을 수 있음
  - class가 상속을 받는 전통적인 방법과 달리 자바스크립트에서는 객체가 직접 다른 객체를 상속 받을 수 있고, 얼마든지 상속 관계를 바꿀 수 있음
  - 만약 super object로부터 상속을 받고 있는 sub object가 다른 객체로부터 상속을 받고 싶다면 링크만 바꿔주면 됨. 
  - 이러한 링크를 prototype link, 그리고 prototype link가 가리키는 객체를 prototype object.
  - __proto__
  - 더 정석적인 방법 :  Object.create()를 사용해 객체를 상속 받는 객체를 생성. 인자로 부모로 지정할 객체를 넣음.
  - debugger; : 자바스크립트의 실행을 일시중지시킬 수 있음, 객체들의 상태를 탐색 가능
  - 자바스크립트의 유연함, 자유분방함.
  - 자바스크립트는에서 함수는 단독으로 쓰일 수도 있다. new가 앞에 있으면 객체를 만드는 생성자로 쓰일 수도 있고 call, bind  등 자유롭고 놀라운 사용법이 존재
  - 자바스크립트에서 모든 함수는 객체기 때문에 call이라는 메소드를 가지고 있다.
  - call : 실행할 때 마다 어떤 함수의 this 값을 바꾸는, context를 바꾸는 함수.
  - call 메소드의 인자로 객체를 지정하게 되면 해당 함수의 this는 인자로 받은 객체가 됨.
  - call은 여러 인자를 가질 수 있음. 첫번째 인자는 this로 지정할 객체가 오고 그 뒤로는 함수의 인자로 들어갈 값
  - bind는 어떤 함수의 내부 this의 값을 영구적으로 바꾸는 새로운 함수를 만들어 냄.
  - 실행할 때 마다 this를 변경하는 것이 아니라 내부적으로 고정시키고 싶다면 bind를 사용.
  - prototype vs __proto__
  - 함수는 자바스크립트에서 객체다. 객체이기 때문에 프로퍼티를 가질 수 있다. 
  - Person 함수를 정의하면 그 함수에 해당하는 Person 객체와 그것의 프로토타입 객체가 생성. 
  - Person 객체는 prototype이라는 프로퍼티가 생기고 그 프로퍼티는 프로토타입 객체를 가리킴.
  - 프로토타입 객체는 constructor라는 프로퍼티를 만들고 그 프로퍼티는 Person을 가리킴.
  - Person.prototype.sum = function(){}는 프로토타입 객체에 sum이라는 메소드를 추가함.
  - var kim = new Person('kim',10,20) 생성자를 이용해 새로운 객체 kim을 만들면
  - constructor 함수가 실행되면서 this의 값이 세팅된 결과 프로퍼티 값들이 생성이 되고 동시에 __proto__ 라는 프로퍼티도 생성
  - __proto__는 해당 객체를 생성한 생성자의 prototype을 가리키게 함. 프로토타입 객체를 가리킴
  - 어떤 객체에서에서 메소드나 프로퍼티를 호출할때 자바스크립트는 먼저 해당 객체에 호출하려는 값이 있는지 살피고 없다면
  - 그 객체의 __proto__ 프로퍼티가 가리키는 prototype 객체에서 호출하려는 값을 찾음
  - class를 이용하지 않고 prototype을 사용해 상속하는 방법. (강사는 class쓰는 걸 추천)
  - 
